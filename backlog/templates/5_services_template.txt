/* create baseResource */  
  const baseResourceCreated = await insertResource(body, baseResourceModel);  
  if (!baseResourceCreated) {
    throw new BadRequestError("baseResource not created!");
  }

/* get all baseResources */  
  const fieldsToReturn = "-password -createdAt -updatedAt";
  const baseResourcesFound = await findAllResources(fieldsToReturn, baseResourceModel);
  if (!baseResourcesFound || baseResourcesFound.length === 0) {
    throw new NotFoundError("No baseResources found");
  }

/* filter all resources by baseResource property */
  const filters = { baseResource_id: baseResource_id };
  const fieldsToReturn = "-password -createdAt -updatedAt";  
  const fieldsFound = await findFilterAllResources(
    filters,
    fieldsToReturn,
    baseResourceModel
  );

/* filter all resources, and populate its properties */
  const baseResourceSearchCriteria = [baseResource_id, baseResource_id];
  const baseResourceFieldsToReturn = "-password -createdAt -updatedAt";
  const baseResourceFieldsToPopulate = "property";
  const baseResourceFieldsToReturnPopulate = "-_id -createdAt -updatedAt";  
  const existingBaseResource = await findPopulateFilterAllResources(
    baseResourceSearchCriteria,
    baseResourceFieldsToReturn,
    baseResourceFieldsToPopulate,
    baseResourceFieldsToReturnPopulate,
    baseResourceModel
  );
  
  if (!existingBaseResource) {
    throw new BadRequestError("Please create the baseResource first");
  }
  if (existingBaseResource.status !== "active") {
    throw new BadRequestError("The baseResource is not active");
  }

/* get the baseResource by id */
  const fieldsToReturn = "-createdAt -updatedAt";  
  const baseResourceFound = await findResourceById(
    baseResourceId,
    fieldsToReturn,
    baseResourceModel
  );
  if (!baseResourceFound) {
    throw new NotFoundError("BaseResource not found");
  }

/* find baseResource by id, and populate its properties */
  const fieldsToReturnBaseResource = "-createdAt -updatedAt";
  const fieldsToPopulateBaseResource = "property";
  const fieldsToReturnPopulateBaseResource = "-password -createdAt -updatedAt";  
  const baseResourceFound = await findPopulateResourceById(
    baseResource_id,
    fieldsToReturnBaseResource,
    fieldsToPopulateBaseResource,
    fieldsToReturnPopulateBaseResource,
    baseResourceModel
  );
  if (!baseResourceFound) {
    throw new BadRequestError("Please make sure the baseResource exists");
  }  

/* find baseResource and its nested resources by id, and populate its properties */
  const fieldsToReturnBaseResource = "-createdAt -updatedAt";
  const fieldsToNestedPopulateBaseResource = [
    {
      path: "school_id",
      select: fieldsToReturnBaseResource,
      model: "School",
    },
    {
      path: "nestedObject01_id",
      select: fieldsToReturnBaseResource,
      model: "nestedObject01",
      populate: {
        path: "nestedObject02_id",
        select: fieldsToReturnBaseResource,
        model: "nestedObject02",
      },
    },
  ];
  const baseResourceFound = await findPopulateNestedResourceById(
    baseResource_id,
    fieldsToReturnBaseResource,
    fieldsToNestedPopulateBaseResource,
    baseResourceModel
  );
  if (!baseResourceFound) {
    throw new BadRequestError("Please make sure the baseResource exists");
  }

/* find baseResource by property */
  const searchCriteria = { property };
  const fieldsToReturn = "-password -createdAt -updatedAt";  
  const duplicatedBaseResource = await findResourceByProperty(
    searchCriteria,
    fieldsToReturn,
    baseResourceModel
  );
  if (duplicatedBaseResource) {
    throw new ConflictError("This baseResource name already exists");
  }

/* find baseResource by properties for the entity */
  const filters = [{ property_id: school_id }, { name: name }];  
  const duplicatedBaseResource = await findFilterResourceByProperty(
    filters,
    fieldsToReturn,
    baseResourceModel
  );
  if (duplicatedBaseResource?.length !== 0) {
    throw new ConflictError("This baseResource name already exists");
  }

/* update baseResource by id */  
  const baseResourceUpdated = await updateResource(baseResourceId, body, baseResourceModel);
  if (!baseResourceUpdated) {
    throw new NotFoundError("BaseResource not updated");
  }

/* update if properties are the same one as the one passed, prevProperty is passed down from the body and used to search the baseResource property to change */
  const filtersUpdate = [
    { _id: baseResourceId },
    { property_id: property_id },
    { prevProperty: prevProperty },
  ];
  const newBaseResource = { property_id: property_id, property: property };  
  const baseResourceUpdated = await updateFilterResource(
    filtersUpdate,
    newBaseResource,
    baseResourceModel
  );
  if (!baseResourceUpdated) {
    throw new NotFoundError("BaseResource not updated");
  }

/* delete baseResource */  
  const baseResourceDeleted = await deleteResource(baseResourceId, baseResourceModel);
  if (!baseResourceDeleted) {
    throw new NotFoundError("BaseResource not deleted");
  }

/* delete field if properties are the same one as the one passed */  
  const filtersDelete = { _id: baseResourceId, property: property };
  const baseResourceDeleted = await deleteFilterResource(filtersDelete, baseResourceModel);
  if (!baseResourceDeleted) {
    throw new NotFoundError("BaseResource not deleted");
  }